# Log----轻量级的日志库

[1.功能特性](#1.功能特性)

​	[1.1 支持四种日志等级](#1.1支持四种日志等级)

​	[1.2 日志函数支持多参数传递](#1.2日志函数支持多参数传递)

[2.日志模式](#2.日志模式)

​	[2.1 同步模式](#2.1同步模式)

​	[2.2异步模式](#2.2异步模式)

​		[2.2.0 设计目标](#2.2.0设计目标)

​		[2.2.1 日志写入线程](#2.2.1日志写入线程)

​		[2.2.2 多缓冲机制](#2.2.2多缓冲机制)

[3.不足之处](#3.不足之处)



## 1.功能特性

### 	1.1支持四种日志等级

**分为：**

**INFO  , DEBUG ,  WARNING , ERROR** 四个等级



### 	1.2日志函数支持多参数传递

定义如下宏， 采用可变参数模板

```c++
//in "log.h"
#define LOG_DEBUG(format, ...)  Log::get_instance()->write_log(0, format, ##__VA_ARGS__);
#define LOG_INFO(format, ...)  Log::get_instance()->write_log(1, format, ##__VA_ARGS__); 
#define LOG_WARN(format, ...)  Log::get_instance()->write_log(2, format, ##__VA_ARGS__); 
#define LOG_ERROR(format, ...) Log::get_instance()->write_log(3, format, ##__VA_ARGS__);

/*如下示例合法*/
LOG_INFO("hello world %d , %s",sockfd,message) ; 
```



### 1.3 设计模式---单例模式

有且仅有一个实例 , 生命周期跟随全局

[C++ 单例模式总结](https://blog.csdn.net/unonoi/article/details/121138176)

## 2.日志模式

日志模式分为：

- 同步模式
- 异步模式

该设置可在`config/config.h`中修改 : `0`为同步模式 ,`1`为异步模式

### 	2.1同步模式

如果某个线程调用日志的宏时,会完成如下操作:

- 竞争锁资源
- 加锁后, 打开文件
- 向日志写入日志行

- 调用结束,继续执行其他操作

通过以上描述 , 很容易得知同步模式效率其实并不高:

因为每个日志行都是直接写入文件的, 且每次调用都会刷新文件缓冲区, 这样的操作一定会带来很大的开销, 并且这一系列操作必然会带来锁资源占用时间变长的情况。如果程序的多个线程都在争用该锁资源,锁资源占用时间变长,导致其他线程阻塞时间变长 , 从而影响整个程序的性能

虽然说同步模式效率不佳,但也并非一无是处, 起码它实现起来非常简单,对吧。



### 	2.2异步模式

#### 2.2.0设计目标

**实现创建日志行和文件写入操作完全分离**, **即日志写入线程与调用日志的线程仅会在交换buffer时进行通信**(互斥锁)

#### 2.2.1日志写入线程

负责将backstage_buffer中的日志行集中写入到文件中, 每次写入会刷新文件缓冲区

#### 2.2.2多缓冲机制

**包含三个缓冲:**

- **cur_buffer**:  调用日志的线程会向该缓冲中写入数据
- **ready_buffer**:就绪缓冲, 如果cur_ buffer被写入一定数据后 ,调用日志的线程将会交换cur_buffer 和 ready_buffer,交换后必须保证ready_buffer为空, 如果不为空会强制清空(这步操作有点暴力, 但是也是无奈之举)
- **backstage_buffer**:日志写入线程负责管理该缓冲 ,每过三秒将数据写入文件

##### 		为什么不只设置两个buffer?

<font color =red>因为两个缓冲区无法保证日志写入操作完全地解耦!</font>

考虑此情况:调用日志的线程在交换缓冲区的同时, 日志写入线程正在把后台缓冲区写入文件, 那么这样的场景必然会造成程序的崩溃

因此,如果仅设置两个buffer,如果想要保证日志写入操作完全地解耦则**必然**会导致线程安全问题

##### 		交换缓冲区的时机

- 调用日志的线程:

  会在当前缓冲区数据量大于512字节时交换 cur_buffer 和  ready_buffer

- 日志写入线程:

  每三秒将缓冲区数据写入文件, 之后获取锁资源后立马交换ready_buffer 和 backstage_buffer

 

## 3.不足之处

### 	3.1恰逢日期更新

日志更新即创建新的日志文件,新的日志文件可能会存有前一天(其实也就是几秒前)的日志行 ,  想要解决这个问题会很复杂, 我觉得没必要为了这样一种发生率很低的事情来大动干戈 ,  影响整个程序性能 。而且少量日志串文件也并不特别影响运营维护

### 	3.2大量日志写入

如果大量日志写入且大大超出日志写入线程处理的范围, 那么将会有大量日志遭到删除,而没有及时写入文件。

#### 可行的解决方案

在相比于此项目, 陈硕的`muduo`网络库中,处于就绪状态的并非一个缓冲区, 而是一个就绪的缓冲区队列, 处于后台的也并非仅一个缓冲区,而是一个待写入的队列, 当出现大量日志写入这样一种极端场景, 程序将更多分配新的缓冲区,来应对突发状况。这种处理非常灵活可以随时释放不必要的buffer 同时也防止了日志的丢失