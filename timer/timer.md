# 连接计时器----基于时间轮实现

时间轮相关博客(https://juejin.cn/post/7083795682313633822)

## 1. 基本概念

> **时间轮** 是一种 **实现延迟功能（定时器）** 的 **巧妙算法**。如果一个系统存在大量的任务调度，时间轮可以高效的利用线程资源来进行批量化调度。把大批量的调度任务全部都绑定时间轮上，通过时间轮进行所有任务的管理，触发以及运行。能够高效地管理各种延时任务，周期任务，通知任务等。

相比于 JDK 自带的 `Timer`、`DelayQueue + ScheduledThreadPool` 来说，时间轮算法是一种非常高效的调度模型。不过，时间轮调度器的时间精度可能不是很高，对于精度要求特别高的调度任务可能不太适合，因为时间轮算法的精度取决于时间段“指针”单元的最小粒度大小。比如时间轮的格子是一秒跳一次，**那么调度精度小于一秒的任务就无法被时间轮所调度**。



## 2.本项目时间轮

上述博客提及, 在众多项目中都存在多级时间轮来管理对象,**可以实现更高的时间跨度的同时保证精度以及内存占用空间**。本项目采用一级时间轮,实现逻辑并不复杂

```c++
/*class timing_wheel 中 */
std::vector<slot*> m_circular_queue; //基于时间轮实现,本项目采用vector容器
int m_tail //时间轮的时针, 指向的槽块中的套接字连接在tick()时将被关闭
```

- **时间轮的精度存在啊限制是否影响程序运行?**

答案是不会! 因为套接字连接关闭并不是刚性要求在某个时间点必须关闭, 可以有稍微延迟或者提前。

- **时间轮的时针偏移**

改变m_tail的值即可:

```c++
/*在每一次tick:*/
m_tail= m_tail == 0 ? m_slot_num -1 :(m_tail - 1) % m_slot_num; //slot_num为时间轮的总槽块数
```



### 2.1 机制

- 当新连接建立时, 主线程需要为对应套接字创建计时器,并将计时器插入至时间轮指定槽块(为m_tail的前一个槽块)

```c++
void timing_wheel::add_timer(timer *user_data);
```

- 当在某个时间轮上发生事件时, 在主线程处理完事件后, 会更新该套接字计时器----此过程线程安全, 全部由主线程进行处理

```c++
void timing_wheel::adjust_timer(int user_fd);
```

- 当在某个套接字上发生异常或者连接状态为`close`, 主线程需要将该套接字对应计时器从时间轮中删除,将调用如下函数:

```c++
timer* timing_wheel::del_timer(int user_fd);
```

